//
//  SiteNavViewController.swift
//  Intapp
//
//  Created by ra3571 on 2/13/15.
//  Copyright (c) 2015 Freescale. All rights reserved.
//

import UIKit
import CoreLocation

protocol Selectable {
    // func sideBarDidSelectMenuButtonAtIndex(index:Int)
    func getSelectedValue() -> AnyObject?
}

class SiteNavViewController: UIViewController, UIPopoverPresentationControllerDelegate {

    var useLocationServices = false
    var locMan: CLLocationManager?
    var initialHeading: Double = 0
    
    @IBOutlet weak var clMessage: UILabel! // the label  used to display the heading
    @IBOutlet weak var webView: UIWebView! // the view that shows the pdf (rotatable?)
    @IBOutlet weak var beaconLabel: UILabel! // the label that shows beacon info "North V-Bldg"
    
    
    @IBAction func listClicked(sender: UIBarButtonItem) {
        if isiOS8 {
            performSegueWithIdentifier("showListAsPopoverSegue", sender: self)
        } else  {
            performSegueWithIdentifier("showListModalSegue", sender: self)
        }
    }
    
    @IBAction func searchClicked(sender: UIBarButtonItem) {
        if isiOS8 {
            performSegueWithIdentifier("navSearch", sender: self)
        } else {
            performSegueWithIdentifier("navSearchLegacy", sender: self)
        }
 
    }
    
    // TODO get from JSON file
   // let conferenceRooms = ["San Jacinto","Seneca","Waterloo","Trinity 1","Trinity 2","Trinity 3","San Gabriel","San Saba"]
    //var confRoomToBldg = [:] as NSMutableDictionary
    var searchResults = []
    
    required init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // trying to get the web view to not overlap with nav bar when rotatating
        webView.sendSubviewToBack(self.view)
        
        // Do any additional setup after loading the view.
        if locManager != nil {
            locMan = locManager!
            locMan!.delegate = self
        }
        
        // Do any additional setup after loading the view.
        let dataUrlStr = "D1.pdf"
        preview(dataUrlStr)

    }
    
    // TODO: make sure this can will not cause error over long period of time.
    func preview(dataUrlStr: String) {
        var docUrl = NSURL(fileURLWithPath: dataUrlStr)
        // if scheme is "file", then the format is just the file name like foo.json or foo.png
        if docUrl?.scheme! == "file" {
            let fileNameWithoutExt = dataUrlStr.stringByDeletingPathExtension
            let ext = dataUrlStr.pathExtension
            docUrl = NSBundle.mainBundle().URLForResource(fileNameWithoutExt, withExtension: ext)
        }
        
        if (docUrl != nil) {
            let req = NSURLRequest(URL: docUrl!)
            webView.loadRequest(req)
         }
    }
    
   
    
    // Mark - UIView Lifecycle
    
    override func viewWillAppear(animated: Bool) {
        locMan!.delegate = self
        //locMan!.startUpdatingHeading()
    }
    
    override func viewWillDisappear(animated: Bool) {
        locMan!.stopUpdatingHeading()
        locMan!.delegate = nil
    }

    
    // MARK: - exit segue
    // this is called by the modal dialog when a table cell is selected
    @IBAction func prepareForUnwind(segue: UIStoryboardSegue) {
        DLog("segue \(segue.identifier) \(segue.sourceViewController.isBeingDismissed())")
        
        if let selectable = segue.sourceViewController as? Selectable {
            if let selectedVal = selectable.getSelectedValue() as? String {
                preview(selectedVal)
            }
        }
        
        // if the source controller is a SiteNavTableViewController and ios8, then we use a popup segue, so we have to dismiss manually
        if let sourceController = segue.sourceViewController as? SiteNavTableViewController {
            if isiOS8 {
                 dismissViewControllerAnimated(true) {}
            }
        }
////
//        
//        // replace with protocol Selectable.getSelectedValue that both SiteNavTableViewController
//        if let sourceController = segue.sourceViewController as? SiteNavTableViewController {
//            // if not being dismissed, dismiss, this handles the case where the SiteNavTableViewController is a popup
//            if sourceController.isBeingDismissed() == false {
//               
//
//            }
//            if let selectedVal = sourceController.selectedValue as? String {
//                preview(selectedVal)
//            }
//        } else if let sourceController = segue.sourceViewController as? SiteNavSearchTableViewController {
//            if let selectedVal = sourceController.selectedValue as? String {
//                preview(selectedVal)
//            }
//        } else if let sourceController = segue.sourceViewController as? IOS7SiteNavSearchTableViewController {
//            if let selectedVal = sourceController.selectedValue as? String {
//                preview(selectedVal)
//            }
//        }
    }
    
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        DLog("\(segue)")
        if let id = segue.identifier {
            if (id == "showListAsPopoverSegue") {
                if let dvc = segue.destinationViewController as? SiteNavTableViewController {
                    // set the dvs as the delegate to the presentation popover
                    if let ppc = dvc.popoverPresentationController {
                        ppc.delegate = self
                    }
                }
            }
        }
    }
    
    /* Keeps the popover presentation controller from trying to show full screen on iPhone
    */
    func adaptivePresentationStyleForPresentationController(controller: UIPresentationController) -> UIModalPresentationStyle {
        return UIModalPresentationStyle.None
    }
    
    private var isiOS8: Bool {
        get {
            return objc_getClass("UIAlertController") != nil
        }
    }

    
   
}

extension SiteNavViewController: CLLocationManagerDelegate {
    
// updateUI(beacon: CLBeacon)
    
    // TODO: get this from a json
    func loadMapForBeacon(beacon: CLBeacon) {
        switch beacon.minor.integerValue {
        case 9252:
            let detailLabel:String = "Major: \(beacon.major.integerValue), " +
                "Minor: \(beacon.minor.integerValue), " +
                "RSSI: \(beacon.rssi as Int), " +
            "UUID: \(beacon.proximityUUID.UUIDString)"
            DLog("open map for \(detailLabel)")
            beaconLabel.text = "W1"
            preview("W1.pdf")
        case 22222:
            beaconLabel.text = "D2"
            preview("D2.pdf")
        default:
            // blank out
            beaconLabel.text = ""
            preview("D1.pdf")
            break
        }
    }
    
    func degreesToRadians(angle: Double) -> CGFloat {
        let rad = (angle) / 180.0 * M_PI
        let ret_val = CGFloat(rad)
        return ret_val
    }
    
    
    // from http://stackoverflow.com/questions/7490660/converting-wind-direction-in-angles-to-text-words
    private func degToCompass(num: Double) -> String {
        let directions = ["N","NNE","NE","ENE","E","ESE", "SE", "SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"]
        let index = Int((num/22.5) + 0.5) % 16
        //NSLog("index \(num) \(index) \(directions.count)")
        let retVal = directions[index]
        return retVal
    }

    func locationManager(manager: CLLocationManager!, didUpdateHeading newHeading: CLHeading!) {
        
        if initialHeading == 0 {
           // initialHeading = newHeading.trueHeading
        }
        // TODO: this will rotate the whole page but it is not working quite right
        //webView.transform = CGAffineTransformMakeRotation(degreesToRadians(initialHeading - newHeading.trueHeading));

        // add code here for heading info
        let compassStr = degToCompass(newHeading.trueHeading)
        let str = NSString(format: "%.1f", newHeading.trueHeading)
        clMessage?.text = "\(compassStr) (\(str))"
    }
    
    func locationManager(manager: CLLocationManager!, didFailWithError error: NSError!) {
        switch error.code {
        case CLError.Denied.rawValue:
            clMessage?.text = "Location Services Off"
            DLog("\(error)")
        case CLError.HeadingFailure.rawValue:
            clMessage?.text = "Compass Heading Failure"
        default:
            DLog("\(error)")
        }
        
    }
    
    func nearestBeaconChanged(nearestBeacon: CLBeacon) {
        lastBeacon = nearestBeacon
        loadMapForBeacon(nearestBeacon)
    }
    
    func nearestProximityChanged(nearestBeacon: CLBeacon) {
        lastProximity = nearestBeacon.proximity;
    }
    
    func locationManager(manager: CLLocationManager!, didRangeBeacons beacons: [AnyObject]!, inRegion region: CLBeaconRegion!) {
            
        var message:String = ""
        
        // get the nearest beacon... this is the beacon with RSS closest to 0 but not zero
        if (beacons.count > 0) {
            
            var nearestBeacon:CLBeacon?
            for beacon in beacons as! [CLBeacon] {
                if beacon.rssi < 0 {
                    nearestBeacon = beacon
                    break
                }
            }
            
            // if we have a nearestbeacon
            if (nearestBeacon != nil) {
                if lastBeacon == nil {
                    nearestBeaconChanged(nearestBeacon!)
                } else {
                    // not nil check the minor number
                    if lastBeacon?.minor == nearestBeacon!.minor {
                        if(nearestBeacon!.proximity == lastProximity || nearestBeacon!.proximity == CLProximity.Unknown) {
                            return  // same so return
                        } else {
                            // the beacon is changed
                            nearestProximityChanged(nearestBeacon!)
                        }
                        return
                    } else {
                        // different so the beacon must be different
                        nearestBeaconChanged(nearestBeacon!)
                    }
                }
            }
        }
    }
    
    func locationManager(manager: CLLocationManager!, didEnterRegion region: CLRegion!) {
        if let clBeaconRegion = region as? CLBeaconRegion {
            DLog("You entered the region")
            beaconLabel.text = "Entered the region"
        }
    }
    
    func locationManager(manager: CLLocationManager!,
        didExitRegion region: CLRegion!) {
            DLog("You exited the region")
            beaconLabel.text = "Exited the region"
    }
    
    
}
